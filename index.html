<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inclined Plane Forces Simulation</title>
    <style>

        /* --- CODE #1 TO PREVENT COPYING --- */
body {
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE10+/Edge */
    user-select: none;         /* Standard */
}
        body { 
            display: grid; 
            place-items: center;
            height: 100vh; 
            margin: 0; 
            background-color: #121212;
            font-family: Arial, sans-serif; 
            text-align: center; 
            color: #e0e0e0;
        }
        main { 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        canvas { 
            border: 2px solid #64ffda;
            background-color: #1e1e1e;
            width: 95vw;
            height: 65vh; 
            max-width: 1400px;
        }
        .controls { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .slider-container { display: flex; align-items: center; gap: 10px; font-size: 16px; min-width: 320px; justify-content: center;}
        #nextButton { padding: 12px 25px; font-size: 16px; cursor: pointer; border: none; border-radius: 8px; background-color: #2a2a2a; color: #64ffda; border: 1px solid #64ffda; transition: background-color 0.3s; }
        #nextButton:hover { background-color: rgba(100, 255, 218, 0.1); }
        #infoText { font-size: 18px; height: 30px; font-weight: bold; color: #e0e0e0; }
        
        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        #logo {
            width: 100px; 
            height: auto;
        }
        h1 {
            color: #e0e0e0;
            font-size: 3em;
            margin: 0;
        }

        /* --- Custom Slider Styles --- */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 160px; 
            height: 20px;
            background: transparent;
            cursor: pointer;
        }
        /* Track for WebKit (Chrome, Safari, Edge) */
        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: #444;
            border-radius: 4px;
        }
        /* Thumb for WebKit */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px;
            height: 20px;
            width: 20px;
            background: #64ffda;
            border-radius: 50%;
            border: 2px solid #1e1e1e;
        }
        /* Track for Firefox */
        input[type="range"]::-moz-range-track {
            height: 8px;
            background: #444;
            border-radius: 4px;
        }
        /* Thumb for Firefox */
        input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            background: #64ffda;
            border-radius: 50%;
            border: 2px solid #1e1e1e;
        }

    </style>
</head>
<body>

    <main>
        <div class="title-container">
            <img id="logo" src="lr-1.png" alt="My Logo">
            <h1 id="mainTitle">Inclined Plane Forces</h1>
        </div>
    
        <canvas id="vectorCanvas"></canvas>
        
        <p id="infoText"></p>

        <div class="controls">
            <div class="slider-container" id="angleSliderContainer" style="display: none;">
                <label for="angleSlider">Angle (θ):</label>
                <input type="range" id="angleSlider" min="0" max="35" value="0" step="1">
                <span id="angleValue">0°</span>
            </div>
            <div class="slider-container" id="staticFrictionContainer" style="display: none;">
                <label for="frictionSlider">Static Friction (μs):</label>
                <input type="range" id="frictionSlider" min="0" max="1.0" value="0.6" step="0.01">
                <span id="frictionValue">0.60</span>
            </div>
            <div class="slider-container" id="kineticFrictionContainer" style="display: none;">
                <label for="kineticFrictionSlider">Kinetic Friction (μk):</label>
                <input type="range" id="kineticFrictionSlider" min="0" max="1.0" value="0.45" step="0.01">
                <span id="kineticFrictionValue">0.45</span>
            </div>
            <button id="nextButton">Next Step</button>
        </div>
    </main>

    <script>

        // --- CODE #2 TO PREVENT COPYING ---
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});
document.onkeydown = function(e) {
    if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.keyCode == 'C'.charCodeAt(0) || e.keyCode == 'J'.charCodeAt(0))) || (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) || (e.ctrlKey && e.keyCode == 'S'.charCodeAt(0))) {
        e.preventDefault();
        return false;
    }
};
// --- END OF SECOND CODE ---
    const canvas = document.getElementById('vectorCanvas');
    const ctx = canvas.getContext('2d');
    const nextButton = document.getElementById('nextButton');
    const infoText = document.getElementById('infoText');
    const angleSlider = document.getElementById('angleSlider');
    const angleValue = document.getElementById('angleValue');
    const frictionSlider = document.getElementById('frictionSlider');
    const frictionValue = document.getElementById('frictionValue');
    const kineticFrictionSlider = document.getElementById('kineticFrictionSlider');
    const kineticFrictionValue = document.getElementById('kineticFrictionValue');
    const angleSliderContainer = document.getElementById('angleSliderContainer');
    const staticFrictionContainer = document.getElementById('staticFrictionContainer');
    const kineticFrictionContainer = document.getElementById('kineticFrictionContainer');

    let step = 0;
    let angleDegrees = 0;
    let angleRadians = 0;
    let mu_s = 0.6;
    let mu_k = 0.45;
    let isAccelerating = false;
    let acceleration = 0;
    let dotPositionRatio = 0.3;
    let dotVelocity = 0;
    let lastTimestamp = 0;
    
    function drawInclinedPlaneResolution() {
        const FgMagnitude = canvas.height * 0.22;
        const mass = FgMagnitude / 9.81;
        
        const { dotX, dotY, planeLength } = drawPlaneAndDot(angleRadians);
        const objectPosition = { x: dotX, y: dotY };
        const startX = objectPosition.x, startY = objectPosition.y;
        
        const FgTipY = objectPosition.y + FgMagnitude;
        drawVector(startX, startY, startX, FgTipY, '#ff6347', 4);
        drawText('Fg', startX + 10, FgTipY, '#ff6347', '18px');
        
        const FgParallelMag = FgMagnitude * Math.sin(angleRadians);
        const FgPerpMag = FgMagnitude * Math.cos(angleRadians);
        const normalForceMag = FgPerpMag;
        const normalEndX = startX - normalForceMag * Math.sin(angleRadians), normalEndY = startY - normalForceMag * Math.cos(angleRadians);
        
        if (step === 0) {
            drawVector(startX, startY, normalEndX, normalEndY, '#ffd700', 5);
            drawText('FN', normalEndX - 30, normalEndY - 5, '#ffd700', '18px');
        }

        if (step >= 1) {
            let frictionForceMag = FgParallelMag;
            
            if (step === 2) { 
                const maxStaticFriction = mu_s * normalForceMag;
                if (FgParallelMag > maxStaticFriction && FgParallelMag > 0.01) {
                    isAccelerating = true;
                    const kineticFrictionForce = mu_k * normalForceMag;
                    frictionForceMag = kineticFrictionForce;
                    const netForce = FgParallelMag - kineticFrictionForce;
                    acceleration = (netForce > 0) ? netForce / mass : 0;
                    if(acceleration <= 0) { isAccelerating = false; dotVelocity = 0;}
                } else {
                    if (isAccelerating) { dotVelocity = 0; }
                    isAccelerating = false; acceleration = 0;
                }
            } else {
                isAccelerating = false; acceleration = 0;
            }
            
            const paraEndX = startX - FgParallelMag * Math.cos(angleRadians), paraEndY = startY + FgParallelMag * Math.sin(angleRadians);
            const perpEndX = startX + FgPerpMag * Math.sin(angleRadians), perpEndY = startY + FgPerpMag * Math.cos(angleRadians);
            const frictionEndX = startX + frictionForceMag * Math.cos(angleRadians), frictionEndY = startY - frictionForceMag * Math.sin(angleRadians);
            
            if (angleRadians > 0) {
                drawDottedLinesForInclinedPlane(objectPosition.x, startY + FgMagnitude, perpEndX, perpEndY, paraEndX, paraEndY);
                drawVector(startX, startY, perpEndX, perpEndY, '#32cd32', 4);
                drawText('Fg cos(θ)', perpEndX + 10, perpEndY + 15, '#32cd32', '16px');
                drawAngleArc(startX, startY, canvas.width * 0.04, angleRadians, 'forces');
                drawVector(startX, startY, normalEndX, normalEndY, '#ffd700', 5);
                drawText('FN', normalEndX - 40, normalEndY - 10, '#ffd700', '18px');
                drawVector(startX, startY, paraEndX, paraEndY, '#1e90ff', 4);
                drawText('Fg sin(θ)', paraEndX - canvas.width * 0.15, paraEndY + 10, '#1e90ff', '16px');
                drawVector(startX, startY, frictionEndX, frictionEndY, '#ff69b4', 5);
                drawText('Ff', frictionEndX + 10, frictionEndY - 10, '#ff69b4', '18px');
            } else {
                drawVector(startX, startY, normalEndX, normalEndY, '#ffd700', 5);
                drawText('FN', normalEndX - 30, normalEndY - 5, '#ffd700', '18px');
            }

            if (isAccelerating) {
                const accelVectorLength = acceleration * (canvas.width * 0.03);
                const accelEndX = startX - accelVectorLength * Math.cos(angleRadians);
                const accelEndY = startY + accelVectorLength * Math.sin(angleRadians);
                drawVector(startX, startY, accelEndX, accelEndY, '#ff8c00', 6);
                drawText('a', accelEndX - 30, accelEndY + 20, '#ff8c00', '18px');
            }
        }
        
        if (step === 2) {
            drawCalculations({ FgParallel: FgParallelMag, Fn: normalForceMag, mass: FgMagnitude / 9.81 });
        }
    }
    
    function drawPlaneAndDot(currentAngle) {
        const planeBaseY = canvas.height * 0.70;
        const planeStartX = canvas.width * 0.05;
        const planeEndX = canvas.width * 0.65;
        const planeLength = planeEndX - planeStartX;
        const planeHeight = planeLength * Math.tan(currentAngle);
        
        const cornerA = { x: planeStartX, y: planeBaseY }; 
        const cornerB = { x: planeEndX, y: planeBaseY };   
        const cornerC = { x: planeEndX, y: planeBaseY - planeHeight }; 
        
        ctx.beginPath();
        ctx.moveTo(cornerA.x, cornerA.y); ctx.lineTo(cornerB.x, cornerB.y); ctx.lineTo(cornerC.x, cornerC.y);
        ctx.closePath();
        ctx.fillStyle = '#333333';
        ctx.fill();
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 2; ctx.stroke();
        if (currentAngle > 0) { drawAngleArc(cornerA.x, cornerA.y, canvas.width * 0.1, currentAngle, 'incline_left'); }
        
        const hypotenuseLength = Math.hypot(cornerA.x - cornerC.x, cornerA.y - cornerC.y);
        const dotX = cornerC.x + (cornerA.x - cornerC.x) * dotPositionRatio;
        const dotY = cornerC.y + (cornerA.y - cornerC.y) * dotPositionRatio;
        ctx.beginPath();
        ctx.arc(dotX, dotY, canvas.width * 0.01, 0, 2 * Math.PI); 
        ctx.fillStyle = '#e0e0e0';
        ctx.fill();
        return { dotX: dotX, dotY: dotY, planeLength: hypotenuseLength };
    }
    
    function drawCalculations(vals) {
        let x = canvas.width * 0.7;
        let y = canvas.height * 0.1;
        const lineHeight = canvas.height * 0.045;
        const fontSize = Math.max(12, canvas.width * 0.013);
        const smallFontSize = Math.max(11, canvas.width * 0.011);
        const textColor = '#e0e0e0';

        drawText('--- Live Calculations ---', x, y, '#64ffda', `${fontSize}px`, 'bold'); y += lineHeight * 1.5;
        drawText('Perpendicular (⊥) Axis:', x, y, textColor, `${smallFontSize}px`, 'bold'); y += lineHeight;
        drawText(`ΣF⊥ = FN - Fg·cos(θ) = 0`, x, y, textColor, `${smallFontSize}px`); y += lineHeight;
        drawText(`FN = 100·cos(${angleDegrees}°) = ${vals.Fn.toFixed(1)} N`, x, y, textColor, `${smallFontSize}px`); y += lineHeight * 1.5;
        drawText('Parallel (∥) Axis:', x, y, textColor, `${smallFontSize}px`, 'bold'); y += lineHeight;
        drawText(`F∥ = 100·sin(${angleDegrees}°) = ${vals.FgParallel.toFixed(1)} N`, x, y, textColor, `${smallFontSize}px`); y += lineHeight;
        const maxStaticFriction = mu_s * vals.Fn;
        drawText(`Ff(max) = μs·FN = ${mu_s.toFixed(2)}·${vals.Fn.toFixed(1)} = ${maxStaticFriction.toFixed(1)} N`, x, y, textColor, `${smallFontSize}px`); y += lineHeight * 1.5;

        if (isAccelerating) {
            drawText(`${vals.FgParallel.toFixed(1)}N > ${maxStaticFriction.toFixed(1)}N => ACCELERATING`, x, y, '#ff6347', `${fontSize}px`, 'bold'); y += lineHeight * 1.2;
            drawText('ΣF∥ = F∥ - Ff(k) = m·a', x, y, textColor, `${smallFontSize}px`); y += lineHeight;
            const kineticFrictionForce = mu_k * vals.Fn;
            const netForce = vals.FgParallel - kineticFrictionForce;
            drawText(`Ff(k) = μk·FN = ${mu_k.toFixed(2)}·${vals.Fn.toFixed(1)} = ${kineticFrictionForce.toFixed(1)} N`, x, y, textColor, `${smallFontSize}px`); y += lineHeight;
            drawText(`F(net) = ${vals.FgParallel.toFixed(1)} - ${kineticFrictionForce.toFixed(1)} = ${netForce.toFixed(1)} N`, x, y, textColor, `${smallFontSize}px`); y += lineHeight;
            drawText(`a = F(net) / m = ${acceleration.toFixed(2)} m/s²`, x, y, textColor, `${smallFontSize}px`, 'bold');
        } else {
            drawText(`${vals.FgParallel.toFixed(1)}N <= ${maxStaticFriction.toFixed(1)}N => STATIC`, x, y, '#32cd32', `${fontSize}px`, 'bold');
            y += lineHeight; 
            drawText(`ΣF∥ = F∥ - Ff(s) = 0`, x, y, textColor, `${smallFontSize}px`);
        }
    }
    
    function drawText(text, x, y, color, size, weight) { ctx.fillStyle = color; const scaledSize = Math.max(12, canvas.width * parseFloat(size)/1000); ctx.font = `${weight} ${scaledSize}px Arial`; ctx.textAlign = 'left'; ctx.fillText(text, x, y); }
    function drawVector(startX, startY, endX, endY, color, width) { if(Math.abs(startX - endX) < 0.1 && Math.abs(startY - endY) < 0.1) return; ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); const vectorAngle = Math.atan2(endY - startY, endX - startX); const size = width * 2 + 4; ctx.save(); ctx.translate(endX, endY); ctx.rotate(vectorAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-size, -size/2); ctx.lineTo(-size, size/2); ctx.closePath(); ctx.fillStyle = color; ctx.fill(); ctx.restore(); }
    function drawAngleArc(x, y, radius, angle, type) { if (angle <= 0) return; ctx.beginPath(); ctx.lineWidth = 2; const fontSize = Math.max(12, canvas.width * 0.015); if (type === 'incline_left') { ctx.strokeStyle = '#888888'; ctx.arc(x, y, radius, 0, -angle, true); drawText('θ', x + radius * 0.7, y - radius * 0.3, '#e0e0e0', `${fontSize}px`, 'italic'); } else if (type === 'forces') { const startAngle = Math.PI / 2; const endAngle = startAngle - angle; ctx.strokeStyle = '#64ffda'; ctx.arc(x, y, radius, startAngle, endAngle, true); const labelAngle = startAngle - angle/2; drawText('θ', x + (radius + 15) * Math.cos(labelAngle), y + (radius + 15) * Math.sin(labelAngle), '#64ffda', `${fontSize}px`, 'italic'); } ctx.stroke(); }
    function drawDottedLinesForInclinedPlane(FgTipX, FgTipY, perpEndX, perpEndY, paraEndX, paraEndY) { ctx.save(); ctx.setLineDash([5, 5]); ctx.strokeStyle = '#666666'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(FgTipX, FgTipY); ctx.lineTo(perpEndX, perpEndY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(FgTipX, FgTipY); ctx.lineTo(paraEndX, paraEndY); ctx.stroke(); ctx.restore(); }
    
    function updateLabelsAndText() {
        angleSliderContainer.style.display = (step === 1 || step === 2) ? 'flex' : 'none';
        staticFrictionContainer.style.display = (step === 2) ? 'flex' : 'none';
        kineticFrictionContainer.style.display = (step === 2) ? 'flex' : 'none';

        switch (step) {
            case 0:
                infoText.textContent = 'On a flat surface, FN equals Fg. The net force is zero.';
                nextButton.textContent = 'Next';
                break;
            case 1:
                infoText.textContent = 'On an inclined plane, forces resolve. Use the slider to see how they change.';
                nextButton.textContent = 'Activate Live Simulation';
                break;
            case 2:
                infoText.textContent = 'Set friction (μs, μk), then increase the angle. The block accelerates when F∥ > Ff(max).';
                nextButton.textContent = 'Reset Simulation';
                break;
            default:
                step = 0;
                angleDegrees = 0;
                angleRadians = 0;
                angleSlider.value = 0;
                angleValue.textContent = '0°';
                isAccelerating = false; dotPositionRatio = 0.3; dotVelocity = 0;
                updateLabelsAndText();
                break;
        }
    }
    
    nextButton.addEventListener('click', () => {
        if (step === 1) {
            angleDegrees = 0;
            angleRadians = 0;
            angleSlider.value = 0;
            angleValue.textContent = '0°';
            
            mu_s = 0.31;
            frictionSlider.value = mu_s;
            frictionValue.textContent = mu_s.toFixed(2);
        }
        step++;
        updateLabelsAndText();
        redrawCanvas();
    });
    
    function animationLoop(timestamp) { if (lastTimestamp === 0) { lastTimestamp = timestamp; } const dt = (timestamp - lastTimestamp) / 1000; if (step === 2 && isAccelerating) { const { planeLength } = drawPlaneAndDot(angleRadians); const visualAcceleration = acceleration * (canvas.width * 0.05); dotVelocity += visualAcceleration * dt; const distanceMoved = dotVelocity * dt; dotPositionRatio += distanceMoved / planeLength; if (dotPositionRatio >= 1) { dotPositionRatio = 1; isAccelerating = false; dotVelocity = 0; } updateLabelsAndText(); redrawCanvas(); } lastTimestamp = timestamp; requestAnimationFrame(animationLoop); }
    function setupCanvas() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; redrawCanvas(); }
    function redrawCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawInclinedPlaneResolution(); }
    window.addEventListener('resize', setupCanvas);
    angleSlider.addEventListener('input', (event) => { angleDegrees = parseFloat(event.target.value); angleRadians = angleDegrees * Math.PI / 180; redrawCanvas(); angleValue.textContent = `${angleDegrees}°`; });
    frictionSlider.addEventListener('input', (event) => { mu_s = parseFloat(event.target.value); frictionValue.textContent = mu_s.toFixed(2); if(step===2) redrawCanvas(); });
    kineticFrictionSlider.addEventListener('input', (event) => { mu_k = parseFloat(event.target.value); kineticFrictionValue.textContent = mu_k.toFixed(2); if(step===2) redrawCanvas(); });
    
    setupCanvas();
    updateLabelsAndText();
    requestAnimationFrame(animationLoop);
    </script>
</body>
</html>
